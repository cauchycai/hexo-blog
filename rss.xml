<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>Thinking Aloud</title>
    <link>http://www.cauchy.me</link>
    <description>自言自语的思想草稿</description>
    
    <item>
      <title>Welcome to Jekyll!</title>
      <link>/jekyll/update/2014/02/07/welcome-to-jekyll.html</link>
      <pubDate>2014-02-07 05:38 GMT</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>You&#39;ll find this post in your <code>_posts</code> directory - edit this post and re-build (or run with the <code>-w</code> switch) to see your changes!
To add new posts, simply add a file in the <code>_posts</code> directory that follows the convention: YYYY-MM-DD-name-of-post.ext.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<div class="highlight"><pre><code class="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">&quot;Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">&#39;Tom&#39;</span><span class="p">)</span>
<span class="c1">#=&gt; prints &#39;Hi, Tom&#39; to STDOUT.</span>
</code></pre></div>

<p>Check out the <a href="http://jekyllrb.com">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/mojombo/jekyll">Jekyll&#39;s GitHub repo</a>.</p>
]]></description>
    </item>
    
    <item>
      <title>把豆瓣电台做成闹钟</title>
      <link>/2013/11/26/osx-automator.html</link>
      <pubDate>2013-11-26 22:40 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
在我的生物钟变得足够强大之前，我会一直需要一个闹钟。我想要的是闹钟能让我无痛的醒来，或者甚至我一听到它就会迫不及待得想起床。豆瓣电台是最接近我想象的那只闹钟。 
</p>

<p>
剩下就是让它每天早上7点自动打开。在MacOSX上还是很好实现的。我能想到的有两种方法：
</p>

<ol class="org-ol">
<li>让Mac在早上6:55自动唤醒。然后添加一个cron任务执行一个写好的shell脚本——在每天早上7点执行 open <a href="http://douban.fm">http://douban.fm</a> 。open命令是OSX自带的，带上Web URL作为参数时就调用默认浏览器打开此url。
</li>

<li>让Mac在早上6:55自动唤醒。使用OSX系统自带的软件Automator增加一个Calendar Alarm，事件是可以定制的，包括可以定制成打开某个url。添加好之后就会生成一个Calendar事件，最后设置事件触发的时间和每日重复就ok了。
</li>
</ol>

<p>
第一种更简单，但是功能不够强大，比如要是我想让itunes播放某个播放列表作闹钟，用这个方法就做不到了。况且它还需要你懂得cron是什么东东。。
</p>

<p>
第二种的设置步骤：
</p>

<ol class="org-ol">
<li>设置Mac在6:55自动唤醒。在System Preference找到Energy Saver，点右下角Schedule。
</li>
</ol>

<p><img src="http://pic.cauchy.me/201311/schedule.png"></p>

<ol class="org-ol">
<li>调出Automator，添加Calendar Alarm。
</li>
</ol>

<p><img src="http://pic.cauchy.me/201311/select-calendar-alarm.png"></p>

<ol class="org-ol">
<li>搜索Get Specified URLs,拖到右侧。搜索Display Webpages,拖到右侧。
</li>
</ol>

<p><img src="http://pic.cauchy.me/201311/auto-open-doubanfm.png"></p>

<ol class="org-ol">
<li>保存后进入calendar编辑已经自动新建的event。
</li>
</ol>

<p><img src="http://pic.cauchy.me/201311/add-to-calendar.png"></p>

<p>
这样就ok了。Automator很强大，已经有点像我想象中的"机器人"了。
</p>
]]></description>
    </item>
    
    <item>
      <title>用Emacs做时间统计</title>
      <link>/2013/11/11/time-logger.html</link>
      <pubDate>2013-11-11 23:51 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
在Emacs上配置了工作时间记录和统计的一些方法。我要实现的目标是：首先要能精确记录我所有的工作时间——从什么时间到什么时间，在做什么项目；其次我要知道每个任务（开发项目，阅读一本书，学一门课程，等等）所消耗的时间；另外，还要有分类，比如假如我有两个分类分别叫“阅读”和“写程序”，那我就可以知道这周花在阅读上的时间有多少，对比花在写程序的时间是不是太多了。每周，每月做汇总统计。
</p>

<p>
比如这是我上周的周统计(只统计了周四到周日)：
</p>

<pre>
   *Read* 《MacTalk:人生元编程》 p1 ~ p126 [1小时54分钟]
   *Read* 《奇特的一生》 p36 ~ p48 [17分钟]
   *Read* "Anna Karenina" Loc950 ~ Loc1004 [17分钟]
   *Watch* "乔布斯：遗失的访谈" [1小时13分钟]
   *Watch* "Friends S09E23-24;S10E01"  [1小时5分钟]
   *Make* 本地开发环境数据自动备份 [2小时43分钟]
   *Errand* iMac上的nginx，php环境配置 [3小时19分钟]
   *Make* 微信服务号 [10小时53分钟]
   *Write* 日记 [6分钟]

: [-INPUT-] 05:22
: [-OUTPUT-] 00:28
: [-MAKE-] 13:36
: [-ERRAND-] 03:19
: [-READ-] 02:39
: [-WRITE-] 00:06
: [-WATCH-] 02:18
</pre>

<p>
通过使用tag标记类别，我就可以知道自己花在INPUT上的时间远大于OUTPUT。INPUT指的是信息的输入，如阅读、看视频等。OUTPUT是信息从大脑中输出，主要是写东西。INPUT远大于OUTPUT，就说明有大量的信息进入我的大脑，却未经整理（输出的过程事实上是一种整理的过程），最后必然白费了时间去吸收这些信息。这是对时间的很大的浪费。
</p>

<p>
通常我开始工作前会用Emacs打开我的todo.org文件，打开calendar view，然后就像下面这张图。当我在calenda里开始一个task，它就高亮为黄色。
</p>

<p><img style="width:50%;" src="http://pic.cauchy.me/201311/orgmode-calendar.png"></p>

<p>
技术上的实现主要都是在使用Emacs的orgmode自带的功能。另外参考了MTong的blog上关于tag时间统计的方法。以及《奇特的一生》这本书。
</p>
]]></description>
    </item>
    
    <item>
      <title>Pomodoro计时器</title>
      <link>/2013/10/16/pomodoro.html</link>
      <pubDate>2013-10-16 23:28 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
Pomodoro需要一个计时器配合工作：工作25分钟提醒一下，休息5分钟再提醒一下，每个周期30分钟。
</p>

<p>
osx的软件商店里找不到让我满意的工具，还是自己写个脚本吧:
</p>

<pre>
#!/bin/sh
COUNTER=0
POMODOROS=4
TEMPNUM=3
if [ -n "$1" ]; then
        let POMODOROS=$1
        let TEMPNUM=POMODOROS-1
fi
terminal-notifier -message "开始工作~" -title "Cauchy" 
while [ $COUNTER -lt $POMODOROS ]; do
        sleep 1500 
        if [ $COUNTER -lt $TEMPNUM ]; then
                terminal-notifier -message "小休一会儿~" -title "Cauchy" && sleep 300 && terminal-notifier -message "小休结束,开始工作~" -title "Cauchy"
        fi      
        let COUNTER=COUNTER+1
done

terminal-notifier -message "暂停工作，站起来活动一下~" -title "Cauchy" 
</pre>

<p>
假如保存为pomodoro，那我就可以这样使用它：
</p>

<pre>
$ pomodoro 3
</pre>

<p>
这样就表示我想开始一个维持3个pomodoro周期的工作任务，25分钟后收到一次提醒，再过5分钟又有一次提醒，再过25分钟又有一次提醒。。。直到3个周期后提醒工作任务结束。
</p>

<p>
osx上可以使用系统自带的通知中心的形式，需要安装terminal-notifier这个工具:
</p>

<pre>
$ sudo gem install terminal-notifier
</pre>

<p>
最后的效果就像这样子：
</p>

<p>
开始工作：
</p>

<p><img src="http://pic.cauchy.me/201310/notify-start-working.png"></p>

<p>
休息片刻：
</p>

<p><img src="http://pic.cauchy.me/201310/notify-takebreak.png"></p>

<p>
休息结束：
</p>

<p><img src="http://pic.cauchy.me/201310/notify-end-break.png"></p>

<p>
工作结束：
</p>

<p><img src="http://pic.cauchy.me/201310/notify-pause-working.png"></p>

<p>
[注]
</p>

<p>
Pomodoro即番茄工作法（参见百度百科：<a href="http://baike.baidu.com/view/5259318.htm">http://baike.baidu.com/view/5259318.htm</a> ）。它的特点是把工作时间切割，每工作25分钟休息5分钟，休息的时候完全不想工作的内容。几个周期后则增加一次更长的休息时间，比如15分钟，可以站起来活动活动，跟周围人说说话。
</p>

<p>
它的好处在于避免注意力长时间集中所带来的疲倦，另外有规律的切换到休息状态可以减轻正在处理的问题给自己带来的压力——问题再让人头疼我也可以在25分钟后休息一下完全不去想它。每个人应该都有这样的经验，很多一时没头绪的问题，休息了一晚上第二天再来看的时候一下子就想到办法解决了。休息5分钟也能带来同样的效果吧。
</p>

<p>
把工作时间分成一截一截的时候，工作任务本身也自然的细分成了很多更小的任务。面对一个大的问题，我们不可能想好所有实现的细节。只有当把它分成一连串更小的任务，一个一个的去解决，才能无痛的完成看似庞大的工作。每一个pomodoro周期就可以对应到某一个被细分出来的子任务。
</p>
]]></description>
    </item>
    
    <item>
      <title>同步Twitter到Weibo的一个小脚本</title>
      <link>/2013/05/26/tweet-to-weibo.html</link>
      <pubDate>2013-05-26 21:10 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
最近又开始用Twitter，于是想同步weibo和twitter两边发布的信息。具体解决方案是这样的：在一个24小时开机的服务器上配置一个定时脚本执行一段程序，这个程序的功能就是取下该脚本上次执行之后新发布的tweets，然后逐个发布到weibo上。
</p>

<p>
脚本是用python写的，具体内容如下：
</p>

<pre>
from django.http import HttpResponse
from datetime import datetime
import json,urllib2,base64,urllib,re

def replaceLink(matchobj):
        request = urllib2.Request(matchobj.group(0))
        result = urllib2.urlopen(request)
        link_url = result.geturl()
        return link_url


def sync(request):
        f = open('/www/tools/tweet2weibo/last_tweet_id', 'rw')
        last_tweet_id = f.readline()
        f.close()
        request_url = 'http://api.twitter.com/1/statuses/user_timeline.json?user_id=YOUR_USER_ID&since_id=' + last_tweet_id

        req = urllib2.urlopen(request_url)
        tweets_str = req.read()
        print tweets_str+'\n'
        tweets = json.loads(tweets_str)
        if not tweets:
                print 'no tweets'
        else:
                username = "YOUR_USER_NAME"
                password = "YOUR_PASSWORD"
                request = urllib2.Request("https://api.weibo.com/2/statuses/update.json")
                base64string = base64.encodestring('%s:%s' % (username, password)).replace('\n', '')
                request.add_header("Authorization", "Basic %s" % base64string)   
                for tweet in tweets:
                        if tweet[u'id_str'] != last_tweet_id:
                                post_url = 'https://api.weibo.com/2/statuses/update.json'
                                status = re.sub(r'https?:\/\/t\.co\/[0-9a-zA-Z]*', replaceLink, tweet[u'text']) 
                                status = status.encode('utf8')

                                values = {
                                        'source' : 'YOUR_APP_KEY',
                                        'status' : status
                                }

                                data = urllib.urlencode(values)
                                result = urllib2.urlopen(request, data)
                f = open('/www/tools/tweet2weibo/last_tweet_id', 'w')
                last_tweet_id = tweets[0][u'id_str']
                f.write(last_tweet_id)
                f.close()
        return HttpResponse('success')
</pre>

<p>
解释一下代码，获取tweets没啥好说的，twitter的接口直接get就ok了。weibo的发布这里需要首先在api.weibo.com申请一个APP，并且记下APP\<sub>KEY，使用支持basic</sub> auth的接口来进行发布。
</p>

<p>
另外，测试时发现了一个问题，因为发布tweet时twitter会把文本中的链接自动转为t.co的短地址，而这样的地址发布到weibo时是无法成功的（weibo认为这种链接不安全）。所以必须先将tweet中的链接地址获取一下原始地址（见replaceLink函数），然后用这个原始地址替换t.co的地址。这样操作之后发布就ok了。
</p>
]]></description>
    </item>
    
    <item>
      <title>Django Service Config on CentOS</title>
      <link>/2013/05/25/service-config-for-django.html</link>
      <pubDate>2013-05-25 16:27 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
Django默认没有安装service启动的脚本，偏偏每次改过都要手动重启manage.py（先从进程中kill掉，再执行启动），如果有多个project需要重启，那就更加麻烦了。
</p>

<p>
在Django官方文档里找了个类似的脚本，但是只支持ubuntu，centos上需要修改。我把修改过的贴下。
</p>

<p>
首先创建文件 /etc/init.d/django-fcg
</p>

<pre>
#! /bin/sh
### BEGIN INIT INFO
# Provides:          FastCGI servers for Django
# Required-Start:    networking
# Required-Stop:     networking
# Default-Start:     2 3 4 5
# Default-Stop:      S 0 1 6
# Short-Description: Start FastCGI servers with Django.
# Description:       Django, in order to operate with FastCGI, must be started
#                    in a very specific way with manage.py. This must be done
#                    for each DJango web server that has to run.
### END INIT INFO
#
# Author:  Guillermo Fernandez Castellanos
#          <guillermo.fernandez.castellanos AT gmail.com>.
#
# Version: @(#)fastcgi 0.1 11-Jan-2007 guillermo.fernandez.castellanos AT gmail.com
#


# Source function library.
. /etc/init.d/functions

#### SERVER SPECIFIC CONFIGURATION
DJANGO_SITES="tools"
SITES_PATH=/www
RUNFILES_PATH=/var/run
HOST=127.0.0.1
PORT_START=8000
RUN_AS=root
FCGI_METHOD=threaded
#### DO NOT CHANGE ANYTHING AFTER THIS LINE!

set -e

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
DESC="FastCGI servers"
NAME=$0
SCRIPTNAME=/etc/init.d/$NAME
#
#       Function that starts the daemon/service.
#
d_start()
{
    # Starting all Django FastCGI processes
    PORT=$PORT_START
    for SITE in $DJANGO_SITES
    do
        echo -n ", $SITE"
        if [ -f $RUNFILES_PATH/django-$SITE.pid ]; then
            echo -n " already running"
        else
            daemon     --pidfile $RUNFILES_PATH/django-$SITE.pid --user $RUN_AS \
                       /usr/bin/python $SITES_PATH/$SITE/manage.py runfcgi \
                       host=$HOST port=$PORT \
                         pidfile=$RUNFILES_PATH/django-$SITE.pid
            chmod 400 $RUNFILES_PATH/django-$SITE.pid
        fi
        let "PORT = $PORT + 1"
    done
}

#
#       Function that stops the daemon/service.
#
d_stop() {
    # Killing all Django FastCGI processes running
    for SITE in $DJANGO_SITES
    do
        echo -n ", $SITE"
        killproc -p $RUNFILES_PATH/django-$SITE.pid \
                          || echo -n " not running"
        if [ -f $RUNFILES_PATH/django-$SITE.pid ]; then
           rm -f $RUNFILES_PATH/django-$SITE.pid
        fi
    done
}

ACTION="$1"
case "$ACTION" in
    start)
        echo -n "Starting $DESC: $NAME"
        d_start
        echo "."
        ;;

    stop)
        echo -n "Stopping $DESC: $NAME"
        d_stop
        echo "."
        ;;

    restart|force-reload)
        echo -n "Restarting $DESC: $NAME"
        d_stop
        sleep 1
        d_start
        echo "."
        ;;

    *)
        echo "Usage: $NAME {start|stop|restart|force-reload}" >&2
        exit 3
        ;;
esac

exit 0

</pre>

<p>
然后还需要修改下 /etc/init.d/functions
找到 daemon 函数
然后把其中的 \<sub>\</sub><sub>pids\</sub><sub>var\</sub><sub>run</sub> "$base" "$pid\<sub>file</sub>" 这一行注释掉，如果不这么做服务就会停在这函数上。具体什么问题我没搞清楚，注释掉貌似也没啥问题。
</p>

<p>
之后就可以用 service django-fcgi start 和 service django-fcgi stop 启动和停止服务了。
</p>
]]></description>
    </item>
    
    <item>
      <title>轻松起床的诀窍</title>
      <link>/2013/03/23/get-up-easily.html</link>
      <pubDate>2013-03-23 16:43 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
摘自“不睡没必要的觉 - 3小时深度睡眠法”这本书。
</p>

<p>
<b>诀窍1：设定起床时间</b>
</p>

<p>
要让自己准时起床，首先要设定起床时间。
</p>

<p>
我们的身体非常奇妙，在每天重复相同的行为中，会自然记住行为的周期。
</p>

<p>
意思是说，不管发生什么事，只要每天在固定时间起床，不管睡眠的时间再短，时间到了自然能够起床。千万不要给自己找借口，“因为前天没睡够” 或 “反正今天不用上班”，等等。不管前一晚几点上床睡觉，都一定要在同一时间起床。
</p>

<p>
<b>诀窍2：沐浴晨光，重新设定生理时钟</b>
</p>

<p>
起床后先走到窗边晒个太阳，张大眼睛，让讯号清楚传送到松果体（松果体被认为是生理时钟的对时器）。
</p>

<p>
只要有2500（Lux）以上的照度，便足够让生理时钟重新对时。
</p>

<p>
常见环境的照度：<br  />
办公室，500（lux）；客厅，100-300（lux）；卧室，30（lux）；太阳，100000（lux）；阴天，10000（lux）；雨天，1000（lux）；街灯，2（lux）；满月，0.2（lux）；弦月，0.01（lux）。
</p>

<p>
<b>诀窍3：回笼觉会让一切努力付诸流水</b>
</p>

<p>
要严禁！
</p>

<p>
第一次清醒过来的时候立即起床！
</p>

<p>
<b>诀窍4：刺激感官的起床法</b>
</p>

<ul class="org-ul">
<li>太阳光刺激视觉
</li>
<li>伸懒腰
</li>
<li>一早起床运动，氧气将优先被送到肌肉而不是脑，有可能让大脑一时无法清醒，但是运动结束后，原供给肌肉的氧气会被送到大脑，就可以立即恢复清醒。
</li>
<li>大声说话，唱歌
</li>
<li>冲个热水澡
</li>
</ul>
]]></description>
    </item>
    
    <item>
      <title>写文章与作演讲 [译]</title>
      <link>/2013/03/09/writing-and-speaking.html</link>
      <pubDate>2013-03-09 22:55 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
作者：Paul Grahum
原文标题：Writing and Speaking
原文地址：<a href="http://www.paulgraham.com/speak.html">http://www.paulgraham.com/speak.html</a>
</p>

<p>
我并不善于演讲，我演讲时断断续续会说很多“呃”，有时我甚至会因为思路中断不得不暂停。当然，我希望自己是一个更好的演讲者，但是相比之下我还是更希望自己是一个更好的写作家。我真正想要的是拥有好的思想，这一点对于一个好的作者更重要的多。
</p>

<p>
拥有好的想法基本上就意味着能写出好的文章。对于写作，当你了解自己在写的主题，并且能用最简练的文字表述，那样读者就会感觉到你的文笔不错。但是对于演讲则正相反，拥有好的想法对于一个作出一个好演讲的作用惊人的小。
</p>

<p>
我第一次注意到这一点是在几年前参加的一次会议上。当时有另一个比我好得多的演讲者，他的发言逗得我们所有人大笑不止。跟他比起来，我看上去讲话既不自然又吞吞吐吐。
</p>

<p>
在这之后我像往常那样把我的讲话内容贴到网上，在这个时候我试着想另外那个人的讲稿整理出来是个什么样子，这时我才发现他的发言其实也没有多少内容。
</p>

<p>
也许对于一个比我更了解演讲本质的人来说这是很明显的事实：相比写作，演讲更少依赖于内容中呈现的思想，但对我来说这还是第一次领悟。<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

<p>
一些年后，我听了一个演讲，这一次演讲者不仅仅是比我更擅长于演讲，可以说他是一个著名的演说家。他实在太棒了，于是我决定集中注意力好好听他说了些什么，想了解他如何做到那么棒。但是在听了差不多十句话之后，我发现自己再也不想做一个好的演讲者了。
</p>

<p>
做一个好的演讲者也不是完全与拥有好的思想无缘，但是事实是两者确实在很多方面相矛盾的。以我自己为例，当我要进行一次演讲，我通常会事先把内容写下来。我知道这样做是错误的，演讲事先写好的稿子会使得讲话过程中与听众的交互更加困难。引起听众注意力的方法恰恰是把自己的全部注意力集中在听众上，但是当你使用预先写好的稿子，你的注意力难免被分成两半，一半在听众一半在你自己的稿子，即使事先已经记住了稿子的内容。如果你想让听众投入到你的演讲，更好的方法是只列出一个提纲，对于具体的内容作即兴的发挥。但是这样一来，对于每一句你说的话，都不会有太多的时间思考，至少不会多于你说出它所费的时间<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>。有时候，面对听众讲话过程中也会激发你想到一些新的东西。但是一般来讲它不如写作更能触发新的想法，因为写作时你可以用任意长的时间来写下一个句子。
</p>

<p>
如果你将一份预先写好的讲稿演练足够多次，也能渐渐达到即兴演讲的效果，就像演员们做到的那样。但这里依旧有一个演讲流利度和思想性之间权衡的问题：所有你花在演练上的时间，也可以用来修改讲稿使之更好。演员不用面对这个问题，除非是他们自己写的剧本。但是每一个演讲者都必须处理这个平衡，通常我在演讲前会自己躲在一个角落拿着一份稿子在大脑中演练。但最终我会发现大部分时间还是变成了我在不断修改稿子的内容。<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup>
</p>

<p>
面对不同的观众，为了迎合他们，有时需要做更多的妥协。听众喜欢听好听的话，他们喜欢笑话，喜欢被激情的语言所感染。面对听众的理解水平越低，那对于一个好演讲者的定义就越等同于衡量他多会吹牛皮。当然这一点对于写作也成立，但对于演讲，这一“本质”体现的更显著。任何一个人作为一个听众时都比作为一个读者更愚蠢（所以说演讲比文字更具煽动性）。因为正如即兴的演讲者思考的时间长度不会超过说出这句话的时间，听众思考和理解这句话的时间也仅限于听到的那一刻。再加上一个听众也总是免不了受到周围人群情绪的感染，而更容易传播的又总是那种更粗浅的情绪，正如低沉的声音相比高音更容易穿透墙壁。一个好的演讲者会利用台下的听众来制造气氛。我在听这个演讲的过程中笑的那么多，部分的原因就是每一个其他人都在笑。<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup>
</p>

<p>
这是否说明演讲没有用处呢？如果说想要获得思想，自然是书写的文字更胜一筹。但要知道演讲的优势并不在此。当我去听一个演说，通常都是因为我对这个演讲者本人感兴趣。对于一些著名的人，比如总统，大部分人最能接近他的方式便是听他的演讲，他不会有时间单独与每一个想见他的人交流。
</p>

<p>
听演讲另一大好处是它能激励我。也难怪那么多的演讲被定义为励志类。这也许是公共演说的真正意义所在，也很有可能是演说最初用作的目的。演说带来的强烈情感力量可以成为行动的强大动力，我希望这种力量更多是被用于正义的事业上，但也许事实并非如此。
</p>

<p>
注：
</p>

<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
我在这里讨论的并非学术演讲，这是完全另一回事。学术演讲的听众往往在喜欢演讲中的笑话的同时，认真理解你所表达的新见解。
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
那是较差的情况，实际中，你通常能做的更好，因为演讲总是关于那些你以前写过或讲过的内容，所以当你即席演说，说的内容也无外乎重新组织句子表达以前曾经表达过的东西。
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
Robert Morris 指出，有一种方法可以让练习演讲的过程也帮助改进讲稿：朗读讲稿可以帮你把不协调的内容暴露出来。我同意这个观点，事实上我也因此会把每一篇我写的东西读上一遍。
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
对于足够少的听众人数，作为听众之一并不会显著降低处理信息时的智力。智力的降低应该会发生在听众多到无法再视之为一个讨论或对话（一般至少超过10人以上吧）。
</p></div>


</div>

<p></div></p>
]]></description>
    </item>
    
    <item>
      <title>博客改名</title>
      <link>/2013/02/26/title-changed.html</link>
      <pubDate>2013-02-26 03:11 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
今天因为一些事失眠了，躺着想睡但是脑子还是不停在自动想着很多事，越睡越清醒，于是干脆起来看会书。博客改的新名字“Thinking Aloud”就是刚才这本书里看到的。
</p>

<p>
我看的书是胡适的传记，讲胡适早年的一些事情和他留学前后的思想变迁。前两年已经读过胡适自己写的那部分日记，传记的大部分内容也无非坏绕那些日记类似的内容，加以考证和修补。“Thinking Aloud”这个词是胡适写在自己日记里的，用中文说的意思就是“自言自语的思想草稿”，我还记得他当时是在拿这个词来说明他写日记的意义：思想如果不能被口头或书写表达出来就不算自己的思想，所以尽可能多的记录下自己的思想有助于把思想变为自己所有。另外坚持的记录也帮助他看到思想随时间变化的轨迹。
</p>

<p>
我也是在看了那段之后开始时时记着要坚持做写日记或写博客这件事，人的大脑就是这么懒惰，吸收信息之后不主动消化就不会变成新的“营养”供日后使用，而消化又好像只有这一个有效的途径——那就是表达。这两年我越来越认识到这件事的关键性，我想变得更好更有智慧，唯有不断实践这个定律。
</p>

<p>
所以，把博客名改成“Thinking Aloud”更能让我时刻意识到我写博客的意义所在。
</p>
]]></description>
    </item>
    
    <item>
      <title>Nora 是很勇敢的</title>
      <link>/2013/02/15/read-a-dolls-house.html</link>
      <pubDate>2013-02-15 11:22 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
读了Ibsen的"A Doll's House"，Nora最终勇敢的走出了这一步——去寻找和认识自我。我忍不住去现实中寻找Nora或者她丈夫Helmer的影子，似乎是很多的，即使是现在这个时代。男人天生就有支配欲，想保护着自己的女人，也同时不能容忍她违背自己的意愿；而女人又何尝不有习惯听从男人权威的天性和文化习惯呢。还有父母对于子女，父母也是习惯了从孩子还是baby就开始的呵护，待孩子成年了还把他看作自己要为之负责的对象或者呵护宠爱的对象，那样这孩子必然也会成为Nora那样，甚至有的不能如Nora那般冲出他的“House”。
</p>

<p>
许多人会不理解Nora的觉醒代表了什么，叫我父母去读这本小书，他们也许仅仅会以为Nora最后是疯了，居然选择离开爱自己的丈夫和三个可爱的孩子。这世上大部分人不都是这样的么，习惯的接受了一个既定的角色，然后为了这个角色而活，女人为了丈夫和孩子而活；丈夫有一个事业，然后就足以在女人面前充当起一把“大伞”的角色，宠着爱着女人，但若二者不能平等的交流，那么这个男人就很有可能也如Nora的丈夫那样只是在享受着自己可以有个人宠着爱着。像Nora那样身在那样一个状态，而不快乐（快乐倒也罢了），但又不觉醒，是最可怜的。我们在爱其他人之前，难道不该先找到自我，不该先学会爱自己么？
</p>
]]></description>
    </item>
    
    <item>
      <title>没有鼠标的生存指南 - （二）Vimium</title>
      <link>/2013/01/27/life-without-a-mouse-2.html</link>
      <pubDate>2013-01-27 05:23 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
仅仅chrome自带的那些快捷键还不足以让我舒适的脱离鼠标浏览网页。
</p>

<p>
不过加上chrome的这个扩展就几乎完美。这个扩展名字叫Vimium，安装地址是：<a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en-US">https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb?hl=en-US</a> 。它为chrome提供了浏览网页时额外的快捷键。由它的名字Vimium不难猜测，快捷键的设置是参照vim编辑器的风格的。
</p>

<p>
没有这个扩展时，下面这些操作是必须用鼠标才能完成的：
</p>

<ul class="org-ul">
<li>页面的上滚下滚，左滚右滚
</li>
<li>定位到输入框
</li>
<li>打开链接
</li>
<li>拷贝一个链接地址
</li>
<li>当前页面浏览历史的前进与后退
</li>
<li>切换标签页
</li>
<li>打开一个收藏的网页
</li>
<li>搜索历史，打开历史中某个页面
</li>
</ul>

<p>
chrome安装了这个扩展之后，这些操作都可以用键盘实现了：
</p>

<ul class="org-ul">
<li>页面上滚下滚：j -&gt; 上滚，k -&gt; 下滚
</li>
<li>页面左滚右滚：h -&gt; 左滚，l -&gt; 右滚
</li>
<li>定位到输入框/打开链接：f 或 F （按下f或F后页面可视区域内所有链接都会表上黄色字母，再键入链接对应的字母就会打开链接，如果字母在输入框上则定位到输入框）
</li>
<li>拷贝一个链接地址：yf
</li>
<li>当前页面历史的前进与后退：H -&gt; 后退，L -&gt; 前进
</li>
<li>切换标签页：K -&gt; 下一个标签页，J -&gt; 上一个标签页
</li>
<li>打开一个收藏的网页：b 或 B
</li>
<li>搜索和打开历史中的一个网页：o 或 O
</li>
</ul>
]]></description>
    </item>
    
    <item>
      <title>早起的技巧</title>
      <link>/2013/01/27/techniques-for-waking-up-early.html</link>
      <pubDate>2013-01-27 04:01 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
摘译了一篇关于如何养成早起习惯的文章。原文链接：<a href="http://zenhabits.net/early/">http://zenhabits.net/early/</a> 。
</p>

<h4>渐进的改变</h4>

<p>
改变早上起床时间的最好方法是渐进的去改变它——每次改变控制在10-15分钟，保持2-4天，如果适应了，就再把时间调早10-15分钟，重复这个过程，知道调整到想要的起床时间。如果你平时8点起床，不要一下子改变到6点，先试试7点45。
</p>

<p>
对于大部分人来说，这过程可能太慢了，当然你可以完全不采纳这个建议。然而，经过我自己的很多试验发现，对改变起床时间最舒适和最容易保持的方法是慢而渐进式的。事实上，其他类型习惯的养成也是一样的。
</p>

<h4>三步加快起床</h4>

<p>
有时候当早上闹钟响时，你其实已经醒了，但就是更情愿在被子里呆着，没有能量爬起来。碰到这种情况的，我们还可以这样：
</p>

<ol class="org-ol">
<li>让自己兴奋起来。在前一天晚上想好一件事——你第二天早上想要去做的事，用来刺激你。这件事可以是某篇你想写的文字，或者瑜伽练习，或者一本你想读的书，或者也可以是计划一个最近开始的工作项目。早晨醒来，当你想起这件事，你会动力百倍，特别是这件事你喜欢做的话。
</li>

<li>蹦下床。大声的伸个懒腰，也会把人醒个大半。然后趁势猛地掀开被子跳下床。又快又没有痛苦。
</li>

<li>把闹钟放远一点。当它靠得很近，你很容易会在它响的时候一下把它摁掉，然后继续睡。放远一点，让你不得不起床去摁掉，然后顺便去小个便，小完便你就差不多清醒了。
</li>
</ol>

<h4>刚起床时最适宜做的事</h4>

<p>
千万不要刚刚起床就开始做你白天不断重复在做的事，比如查收邮件，刷微博，看新闻之类。
</p>

<p>
刚起床时适合做的事：
</p>

<ol class="org-ol">
<li>喝一杯水。一整夜没有摄取水分，身体这时候往往已经很缺乏水分了。喝一整杯水，你的大脑会更清醒。
</li>

<li>冥想。即便只做3分钟的时间。通过这种练习大脑集中力的方式，可以更快的切换睡眠状态到清醒状态。
</li>

<li>写。写写东西，无论什么，日记，一天的工作计划，或者整理自己的笔记都可以。刚醒来时，大脑尚处于右脑工作模式，这时候是最能发挥创造力，思维最敏捷的时间，因此只需稍作尝试你就会发现会有好多好多的想法从脑子里冒出来。
</li>

<li>晨练。不行或小跑。
</li>

<li>喝一杯咖啡或茶。
</li>
</ol>

<h4>睡得更早</h4>

<p>
保证自己7-8.5小时的睡眠。睡前不要使用液晶屏设备——手机、电脑、iPad、电视机等等，不仅仅是液晶荧光屏的问题，主要是从这些设备获取信息，无论是社交媒体，还是新闻，还是游戏，还是聊天，都是让大脑处于高负荷状态的，睡前食用会影响你进入高质量的睡眠。
</p>

<p>
相比之下，选择睡前阅读书籍，会让人更自然的入睡。
</p>

<p>
当你快入睡时，想一下第二天一早起来要做的那件让你兴奋的事，那样，第二天一醒来你就会立刻想起那件事而迫不及待的要起床。
</p>
]]></description>
    </item>
    
    <item>
      <title>flac文件分割并转成mp3的一个脚本</title>
      <link>/2013/01/07/flac-to-mp3.html</link>
      <pubDate>2013-01-07 14:46 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>bash脚本：flac<em>to</em>mp3</p>

<pre>
#!/bin/sh
if [ $# -lt 3 ]
then
        echo "Usage: $0 example.cue example.flac destDir"
        exit 1
fi

cue_file=$1
audio_file=$2
dest_dir=$3
mkdir -p "$dest_dir"
echo "Export files to $dest_dir"

shntool split -t "%n.%t" -f "$cue_file" -o 'cust ext=mp3 lame --r3mix -b 320 --quiet - %f' "$audio_file" -d "$dest_dir"

echo "Writing id3 info..."
track_count=`cueprint -d '%N' "$cue_file"`
track_index=1
while [ $track_index -le $track_count ]
do
        artist=`cueprint -n$track_index -t '%p' "$cue_file"`
        album=`cueprint -n$track_index -t '%T' "$cue_file"`
        tracknum=`cueprint -n$track_index -t '%02n' "$cue_file"`
        title=`cueprint -n$track_index -t '%t' "$cue_file"`
        mid3v2 --artist="$artist" --album="$album" --track="$tracknum" --song="$title" "$dest_dir/$tracknum.$title.mp3"
        track_index=$(expr $track_index + 1 )
done
</pre>

<p>
使用：flac\<sub>to\</sub><sub>mp3</sub> example.cue example.flac destDir
</p>

<p>
cue文件如果不是utf-8编码的必须转成utf-8编码。
</p>

<p>
脚本中用到的一些命令需要预先安装下列程序：flac,shntool,lame,cuetools,mutagen。
</p>
]]></description>
    </item>
    
    <item>
      <title>Dd Wrt Config</title>
      <link>/2012/12/15/dd-wrt-config.html</link>
      <pubDate>2012-12-15 00:00 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">刷dd-wrt系统</a></li>
<li><a href="#sec-2">硬盘分区</a></li>
<li><a href="#sec-3">硬盘挂载</a></li>
<li><a href="#sec-4">安装OPKG</a></li>
<li><a href="#sec-5">安装transmission</a></li>
<li><a href="#sec-6">配置启动脚本</a></li>
</ul>
</div>

<h2></div></h2>

<p>layout: post
title: dd-wrt配置记录 - transmission安装
date:  2012-12-16 14:36 +0800
tags: [配置,路由器]
excerpt: &quot; 1.路由器要刷好dd-wrt系统;
 2.准备一个分好区的硬盘，通过usb连到路由器，分区格式必须是linux可以支持的，比如ext3;
 3.硬盘挂载;
 4.安装OPKG，这是OpenWRT的软件包管理工具;
 5.安装transmission;
 6.增加启动脚本。</p>

<h2>&quot;</h2>

<p>
今年上半年的时候买了个可以刷dd-wrt系统的路由器，另外这个路由器提供了一个usb接口，可以外接硬盘或打印机。把它连上硬盘就可以直接配置成nas服务器了，我就是看中这个。买回来立马刷了dd-wrt，然后连上移动硬盘，开启局域网共享，于是我把电影照片统统拷到这个共享空间上，想看的时候直接访问共享然后打开播放，不再需要时不时插移动硬盘到笔记本上，真是清爽极了啊！然后尝试在路由器上安装transmission这个bt客户端时，却怎么都装不上，找了n久都没找到合适的软件包。积极性被打击到了，然后就放弃了，暂时放弃了，考虑到我也实在没有那么多时间看下载的资源（这半年我连电影都没看过几部）。
</p>

<p>
最近听一个同事又讲起配置路由器支持bt下载，让我又想试试重新配置路由器。
</p>

<p>
这次用了openwrt的软件包来安装transmission。主要步骤是：
</p>

<p>
1.路由器要刷好dd-wrt系统;<br  />
 2.准备一个分好区的硬盘，通过usb连到路由器，分区格式必须是linux可以支持的，比如ext3;<br  />
 3.硬盘挂载;<br  />
 4.安装OPKG，这是OpenWRT的软件包管理工具;<br  />
 5.安装transmission;<br  />
 6.增加启动脚本。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">刷dd-wrt系统</h2>
<div class="outline-text-2" id="text-1">
<p>
这步很简单，不说了。
</p>
</div>

<p></div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">硬盘分区</h2>
<div class="outline-text-2" id="text-2">
<p>
如果用的linux可以用Gparted这个软件，windows可以用硬盘分区大师之类软件。所有分区都设为ext3类型，留一个分区给系统装软件用，大小1G～4G，用来放安装的软件，因为路由器的rom只有64M。
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">硬盘挂载</h2>
<div class="outline-text-2" id="text-3">
<p>
在dd-wrt路由器的web设置界面开启jffs2文件系统支持，ssh连接支持，usb挂载支持，并选择自动挂载到/mnt。通过ssh链接到路由器，密码就是路由器web登录的密码，但是用户名当然得是root。查看下是否有 /jffs 这个目录，系统其他目录都是只读的，只有这个目录下可以写并且重启路由后数据仍保留着。因为系统是只读的所以无法装额外的软件，可以挂载安装路径到 /jffs 下的某个目录，但是jffs只有16M的空间，所以还是单独在硬盘上分了一个区然后挂载到系统上用来存放安装的软件。
</p></p>

<p>
假设硬盘上有两个分区，/dev/sda1 和 /dev/sda2 , 分别挂载到 /jffs/system 和 /jffs/data :
</p>

<pre>
# mkdir /jffs/system; mkdir /jffs/data
# mount -t ext3 /dev/sda1 /jffs/system
# mount -t ext3 /dev/sda2 /jffs/data
</pre>

<p>
/jffs/data目录用来存放文件做网络共享，在dd-wrt的web配置界面找到File sharing下的samba，即可配置windows共享。
</p>

<p>
系统中/etc和/opt分别是配置文件目录和安装软件的目录，把 /etc 和 /opt 文件夹下所有文件分别拷到 /jffs/system/etc 和 /jffs/system/opt ,然后分别挂载这两个目录到 /etc 和 /opt ：
</p>

<pre>
# mkdir /jffs/system/etc; mkdir /jffs/system/opt
# cp -a /etc/* /jffs/system/etc/
# mount -o bind /jffs/system/etc/ /etc/
# mount -o bind /jffs/system/opt/ /opt/
</pre>

<p>
这样/etc和/opt两个目录就有了写的权限了。
</p>

<p></div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">安装OPKG</h2>
<div class="outline-text-2" id="text-4">
<p>
OPKG是用来管理软件包的，就像ubuntu的apt-get和redhat的yum。首先手动下载这个软件，软件包来自这个站点：<a href="http://downloads.openwrt.org/snapshots/trunk/">OpenWRT Project</a> 。
</p></p>

<pre>
# mkdir /jffs/installers; cd /jffs/installers 
# wget http://downloads.openwrt.org/snapshots/trunk/ar71xx/packages/opkg_618-3_ar71xx.ipk
</pre>

<p>
安装：
</p>

<pre>
# ipkg install opkg_618-3_ar71xx.ipk
</pre>

<p>
安装opkg依赖的库文件：
</p>

<pre>
# wget http://downloads.openwrt.org/snapshots/trunk/ar71xx/openwrt-ar71xx-generic-rootfs.tar.gz
# cd /jffs/installers; tar xvzf openwrt-ar71xx-generic-rootfs.tar.gz
# cp -Pp /jffs/installers/lib/* /jffs/usr/lib/
</pre>

<p>
将/jffs/usr/lib/ 添加到环境变量“LD<sub>LIBRARY</sub><sub>PATH”中</sub>
</p>

<pre>
# export LD_LIBRARY_PATH=/jffs/usr/lib:$LD_LIBRARY_PATH
</pre>

<p>
把opkg软件的配置文件拷到/etc 并修改：
</p>

<pre>
# cp /jffs/etc/opkg.conf /etc/
# vi /etc/opkg.conf
</pre>

<p>
修改为下面的内容：
</p>

<pre>
src/gz snapshots http://downloads.openwrt.org/snapshots/trunk/ar71xx/packages
dest root /opt
dest ram /tmp
lists_dir ext /opt/var/opkg-lists
option overlay_root /overlay
</pre>

<p>
lists\<sub>dir保存软件包的数据库，占用1</sub>.5M容量，因此还是放在/opt下，要预先创建好/opt/var目录。然后更新和查看软件包信息：
</p>

<pre>
# mkdir /opt/var
# opkg update; opkg list
</pre>

<p></div>
</div></p>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">安装transmission</h2>
<div class="outline-text-2" id="text-5">
<p>
在dd-wrt的web管理界面启用UPnP Configuration下的两个选项。
</p>

<p>
安装软件包,运行并初始化（-f参数）：
</p>

<pre>
# opkg update; opkg install transmission-daemon
# transmission-daemon -f
</pre>

<p>
10秒后按Ctrl+C终止掉transmission-daemon，创建下载目录和配置文件目录：
</p>

<pre>
# mkdir -p /jffs/data/torrents/parts/
# mkdir -p /jffs/data/torrents/config/
# cp /tmp/root/.config/transmission-daemon/settings.json /jffs/data/torrents/config/
</pre>

<p>
transmission-daemon没有cli界面，更没有图形界面，但是可以远程管理。远程管理一种是在路由器上安装transmission-web，然后远程通过浏览器访问管理;另一种不需要安装软件，直接在远程机器上安装remote GUI来管理。在这之前需要将远程访问来源的ip加入配置文件的白名单中，编辑/jffs/data/torrents/config/settings.json,修改rpc-whitelist项。添加了自己电脑的ip之后就可以运行transmission，然后进行管理了。
</p>

<pre>
# transmission-daemon -g /jffs/data/torrents/config
</pre>
</div>

<p></div></p>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">配置启动脚本</h2>
<div class="outline-text-2" id="text-6">
<p>
路由器重启后所有设置被重置，但是可以加启动脚本，在启动脚本里重新执行这些步骤：
</p>

<pre>
#!/bin/sh
sleep 30
umount /dev/sda1
umount /dev/sda2
mount -t ext3 /dev/sda1 /jffs/system
mount -t ext3 /dev/sda2 /jffs/data
mount -o bind /jffs/system/etc/ /etc/
mount -o bind /jffs/system/opt/ /opt/
if [[ -z "`cat /tmp/root/.profile | grep "/jffs/usr/lib:/opt/usr/lib"`" ]]; then
    export TMP=$LD_LIBRARY_PATH                                                
    export LD_LIBRARY_PATH=/jffs/usr/lib:/opt/usr/lib:$TMP                     
    echo "LD_LIBRARY_PATH='/jffs/usr/lib:/opt/usr/lib:$TMP'" >>/tmp/root/.profile
fi
/opt/usr/bin/transmission-daemon -g /jffs/data/torrents/config 
</pre>

<p>
保存为/jffs/etc/startup.sh 。然后在dd-wrt的web管理界面找到startup commands，填入如下内容：
</p>

<pre>
/jffs/etc/startup.sh
</pre>

<p>
重启路由器。这样配置就完成了。
</p>
</div>

<p></div></p>
]]></description>
    </item>
    
    <item>
      <title>没有鼠标的生存指南</title>
      <link>/2012/12/08/life-without-a-mouse.html</link>
      <pubDate>2012-12-08 16:41 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
鼠标实在是一个不怎么样的发明，加剧身体左右两侧的不平衡不说，用鼠标来操作计算机通常都只能让人养成非常低效的操作习惯。所以我越来越喜欢键盘，键盘操作非常快捷，而且还不会有使用鼠标时大脑思考被迫停滞的现象。大部分人都不大了解操作系统自带的那些强大的快捷键功能，其实windows7，mac os x，ubuntu这几个常见的操作系统都有强大的系统内建快捷键功能。
</p>

<p>
Windows7的常用快捷键：
</p>

<ul class="org-ul">
<li><b>Windows键</b> + <b>方向下键</b> 窗口为最大化时，将窗口还原;窗口不是最大化时，最小化窗口。
</li>
<li><b>Windows键</b> + <b>方向上键</b> 最大化当前窗口。
</li>
<li><b>Windows键</b> + <b>方向左/右键</b> 将窗口放置在桌面左/右半侧。
</li>
<li><b>Windows键</b> + <b>D</b> 最小化所有窗口，再次按下恢复先前状态。
</li>
<li><b>Windows键</b> + <b>E</b> 打开资源管理器。
</li>
<li><b>Alt</b> + <b>F4</b> 关闭当前窗口。
</li>
<li><b>Alt</b> + <b>空格</b> 显示窗口菜单。
</li>
<li><b>Alt</b> + <b>Tab</b> 切换窗口。
</li>
</ul>

<p>
在windows7下打开某个应用程序其实最简单快捷的方法也完全不是用鼠标点击开始菜单或者桌面项。下面两个方法就更简便：
</p>

<ul class="org-ul">
<li><b>Windows键</b> 调出开始菜单，windows7自带的开始菜单搜索立即会出现，直接输入需要运行的程序。
</li>
<li><b>Windows键</b> + <b>R</b> 运行指定程序。
</li>
</ul>

<p>
Ubuntu就更加强大了，几乎所有的事情都可以用快捷键完成，而且快捷键可以自己修改，自定义用什么组合键来完成某个操作。比较常用的包括：
</p>

<ul class="org-ul">
<li><b>Ctrl</b> + <b>Super</b> + <b>Up</b> 最大化窗口。
</li>
<li><b>Ctrl</b> + <b>Super</b> + <b>Down</b> 还原窗口。
</li>
<li><b>Super</b> + <b>Space</b> 窗体菜单。
</li>
<li><b>Alt</b> + <b>F7</b> 移动窗口。
</li>
<li><b>Alt</b> + <b>F8</b> 改变窗口大小。
</li>
<li><b>Ctrl</b> + <b>Alt</b> + <b>Left/Right/Up/Down</b> 切换到左/右/上/下侧工作区。
</li>
<li><b>Ctrl</b> + <b>Shift</b> + <b>Alt</b> + <b>Left/Right/Up/Down</b> 将当前窗口移动到左/右/上/下工作区。
</li>
<li><b>Ctrl</b> + <b>Alt</b> + <b>T</b> 打开Terminal。
</li>
</ul>

<p>
Chrome浏览器的常用快捷键：
</p>

<ul class="org-ul">
<li><b>Ctrl</b> + <b>Tab</b> 切换到下一个标签页。
</li>
<li><b>Ctrl</b> + <b>Shift</b> + <b>Tab</b> 切换到上一个标签页。
</li>
<li><b>Ctrl</b> + <b>数字键</b> 切换到第n个标签页。
</li>
<li><b>Alt</b> + <b>方向左键/方向右键</b> 后退/前进。
</li>
<li><b>Ctrl</b> + <b>W</b> 关闭当前tab。
</li>
<li><b>Ctrl</b> + <b>Shift</b> + <b>W</b> 关闭所有tab。
</li>
<li><b>Ctrl</b> + <b>Shift</b> + <b>T</b> 重新打开上一个关闭的tab。
</li>
<li><b>Alt</b> + <b>D</b> 将光标定位到地址栏。
</li>
<li><b>Alt</b> + <b>F</b> 打开设置菜单。
</li>
<li><b>F6</b> 在地址栏，工具栏和网页间切换光标定位。
</li>
<li><b>Ctrl</b> + <b>U</b> 网页源文件。
</li>
<li><b>Ctrl</b> + <b>J</b> 下载列表。
</li>
<li><b>F12</b> 打开Develop Tools
</li>
<li><b>Ctrl</b> + <b>Shift</b> + <b>J</b> 打开Develop Tools，并切换至Console标签页。
</li>
</ul>

<p>
对于我来说，有了这些，再加上平时用的编辑器支持全部的用键盘操作，这样大部分时候两个手就不再需要离开键盘了。
</p>
]]></description>
    </item>
    
    <item>
      <title>第一篇</title>
      <link>/2012/12/05/the-real-first-post.html</link>
      <pubDate>2012-12-05 23:55 UTC</pubDate>
      <author>cauchy.cai At gmail.com (Cauchy Cai)</author>
      <description><![CDATA[<p>
简单“装修”了下，这就是我在网络上的新“家”了。 
</p>

<p>
以后一定要坚持多多浇灌这个空间。对于我来说，写博客主要的目的是巩固自己的所学。写是很重要的，写的过程才是思考的过程，仅仅是学习了某个技术或者甚至写了挺多的代码，往往都还不足以把零碎的知识点连成体系。知识一定要形成体系，就计算机技术来说，如果没有一个紧密的知识体系，只知道这样那样的技巧，就很难保证自己总能找到最简单的方案来解决问题。其他领域应该也是类似的吧。
</p>

<p>
对于我来说，一直有一个大问题：“输入”太多而“输出”太少，我看很多书，接触过很多很多技术，但总是停留在表面，就像《围城》里的方鸿渐——兴趣极广，心得全无。有时候我觉得我知道的东西真的很多，但是都闷在脑子里，没有途径把它们输出出来，这种感觉是无比难受的。
</p>

<p>
与人交流和分享是最有效的消化知识的途径，表达的过程才是思考的过程。如果对于一个概念我学过看过，但是我不能把它表达出来，那就不能说我理解了这个概念，很多时候我们自以为是意会了就觉得懂了的东西，其实只是懂了一点表面而已。以前常听老师说论文就是“写”出来的，我一直对这个话不认同，觉得没有真材实料光在那凑字数也算论文吗。其实这话说的一点没错，我只是一直没理解，这个“写”太必要了，不去写就没有思考，也就不能发现问题，往往开始写了之后才发现要写的东西越来越多。
</p>

<p>
事实上，还有一点很重要，消化信息的过程会让大脑很舒服，就像以前做数学题，如果顺利的做完了几道难题，本来还没睡醒的脑子也会变得特别清醒。
</p>
]]></description>
    </item>
    
  </channel>
</rss>
