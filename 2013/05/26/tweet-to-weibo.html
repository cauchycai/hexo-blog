<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>同步Twitter到Weibo的一个小脚本</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">Thinking Aloud</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>同步Twitter到Weibo的一个小脚本</h2>
<p class="meta">26 May 2013</p>

<div class="post">
<p>
最近又开始用Twitter，于是想同步weibo和twitter两边发布的信息。具体解决方案是这样的：在一个24小时开机的服务器上配置一个定时脚本执行一段程序，这个程序的功能就是取下该脚本上次执行之后新发布的tweets，然后逐个发布到weibo上。
</p>

<p>
脚本是用python写的，具体内容如下：
</p>

<pre>
from django.http import HttpResponse
from datetime import datetime
import json,urllib2,base64,urllib,re

def replaceLink(matchobj):
        request = urllib2.Request(matchobj.group(0))
        result = urllib2.urlopen(request)
        link_url = result.geturl()
        return link_url


def sync(request):
        f = open('/www/tools/tweet2weibo/last_tweet_id', 'rw')
        last_tweet_id = f.readline()
        f.close()
        request_url = 'http://api.twitter.com/1/statuses/user_timeline.json?user_id=YOUR_USER_ID&since_id=' + last_tweet_id

        req = urllib2.urlopen(request_url)
        tweets_str = req.read()
        print tweets_str+'\n'
        tweets = json.loads(tweets_str)
        if not tweets:
                print 'no tweets'
        else:
                username = "YOUR_USER_NAME"
                password = "YOUR_PASSWORD"
                request = urllib2.Request("https://api.weibo.com/2/statuses/update.json")
                base64string = base64.encodestring('%s:%s' % (username, password)).replace('\n', '')
                request.add_header("Authorization", "Basic %s" % base64string)   
                for tweet in tweets:
                        if tweet[u'id_str'] != last_tweet_id:
                                post_url = 'https://api.weibo.com/2/statuses/update.json'
                                status = re.sub(r'https?:\/\/t\.co\/[0-9a-zA-Z]*', replaceLink, tweet[u'text']) 
                                status = status.encode('utf8')

                                values = {
                                        'source' : 'YOUR_APP_KEY',
                                        'status' : status
                                }

                                data = urllib.urlencode(values)
                                result = urllib2.urlopen(request, data)
                f = open('/www/tools/tweet2weibo/last_tweet_id', 'w')
                last_tweet_id = tweets[0][u'id_str']
                f.write(last_tweet_id)
                f.close()
        return HttpResponse('success')
</pre>

<p>
解释一下代码，获取tweets没啥好说的，twitter的接口直接get就ok了。weibo的发布这里需要首先在api.weibo.com申请一个APP，并且记下APP\<sub>KEY，使用支持basic</sub> auth的接口来进行发布。
</p>

<p>
另外，测试时发现了一个问题，因为发布tweet时twitter会把文本中的链接自动转为t.co的短地址，而这样的地址发布到weibo时是无法成功的（weibo认为这种链接不安全）。所以必须先将tweet中的链接地址获取一下原始地址（见replaceLink函数），然后用这个原始地址替换t.co的地址。这样操作之后发布就ok了。
</p>

</div>


          <div class="footer">
            <div class="contact">
              <p>
                Your Name<br />
                What You Are<br />
                you@example.com
              </p>
            </div>
            <div class="contact">
              <p>
                <a href="https://github.com/yourusername">github.com/yourusername</a><br />
                <a href="https://twitter.com/yourusername">twitter.com/yourusername</a><br />
              </p>
            </div>
          </div>
        </div>

    </body>
</html>
